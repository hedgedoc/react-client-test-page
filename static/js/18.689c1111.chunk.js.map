{"version":3,"sources":["../node_modules/markdown-it-mathjax/markdown-it-mathjax.js","../../index.js","../node_modules/js-yaml/dist/js-yaml.mjs","../node_modules/markdown-it-front-matter/index.js","../node_modules/markdown-it-plantuml/index.js","../node_modules/markdown-it-plantuml/lib/deflate.js","../../../../../../index.js","../webpack:/webpack/bootstrap 0d1a0c903c89c60b9ef4","../../../../../../src/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/use-resize-observer/dist/bundle.esm.js"],"names":["module","exports","math","state","silent","startMathPos","pos","src","charCodeAt","type","endMarker","includeMarkers","match","slice","length","endMarkerPos","indexOf","nextPos","push","content","texMath","afterStartMarker","beforeEndMarker","suffix","escapeHtml","html","replace","extend","options","defaults","Object","keys","reduce","result","key","undefined","mapping","beforeMath","afterMath","beforeInlineMath","afterInlineMath","beforeDisplayMath","afterDisplayMath","md","inline","ruler","before","forEach","after","renderer","rules","tokens","idx","factory","slugify","x","encodeURIComponent","String","trim","toLowerCase","htmlencode","ast","assign","placeholder","uniqueSlugStartIndex","containerClass","containerId","listClass","itemClass","linkClass","level","listType","format","callback","pattern","RegExp","tocOpen","_options","inlineOptions","tocClose","tocBody","selection","uniques","isLevelSelected","Array","isArray","includes","ast2html","tree","c","buffer","l","node","s","u","i","prototype","hasOwnProperty","call","n","core","stack","iK","token","children","filter","t","parseInt","tag","substr","unshift","shift","block","startLine","endLine","lineFirstToken","bMarks","tShift","eMarks","split","test","matches","exec","JSON","parse","ex","line","markup","map","alt","isNothing","subject","common","isObject","toArray","sequence","repeat","string","count","cycle","isNegativeZero","number","Number","NEGATIVE_INFINITY","target","source","index","sourceKeys","formatError","exception","compact","where","message","reason","mark","name","column","snippet","YAMLException","Error","this","captureStackTrace","constructor","create","toString","getLine","lineStart","lineEnd","position","maxLineLength","head","tail","maxHalfLength","Math","floor","str","padStart","max","maxLength","indent","linesBefore","linesAfter","re","lineStarts","lineEnds","foundLineNo","lineNoLength","min","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","kind","resolve","construct","data","instanceOf","predicate","represent","representName","defaultStyle","multi","styleAliases","style","alias","compileStyleAliases","compileList","schema","exclude","currentType","previousType","previousIndex","Schema","definition","implicit","explicit","concat","type$1","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","scalar","fallback","collectType","arguments","compileMap","failsafe","_null","object","canonical","lowercase","uppercase","camelcase","empty","bool","isOctCode","isDecCode","int","ch","hasDigits","value","sign","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","SCIENTIFIC_WITHOUT_DOT","float","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","json","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","timestamp","year","month","day","hour","minute","second","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","merge","BASE64_MAP","code","bitlen","charAt","tailbits","input","bits","Uint8Array","_hasOwnProperty","_toString","omap","pair","pairKey","pairHasKey","objectKeys","_toString$1","pairs","_hasOwnProperty$1","set","_default","_hasOwnProperty$2","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","State","filename","onWarning","legacy","listener","implicitTypes","typeMap","lineIndent","firstTabInLine","documents","generateError","throwError","throwWarning","directiveHandlers","YAML","args","major","minor","version","checkLineBreaks","TAG","handle","prefix","tagMap","decodeURIComponent","err","captureSegment","start","end","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLineStart","startPos","defineProperty","configurable","enumerable","writable","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readBlockSequence","nodeIndent","_line","_tag","_anchor","anchor","detected","anchorMap","composeNode","readTagProperty","tagHandle","tagName","isVerbatim","isNamed","readAnchorProperty","parentIndent","nodeContext","allowToSeek","allowCompact","allowBlockStyles","allowBlockScalars","allowBlockCollections","typeIndex","typeQuantity","typeList","flowIndent","blockIndent","indentStatus","atNewLine","hasContent","following","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readBlockMapping","_lineStart","_pos","terminator","isPair","isExplicitPair","isMapping","readNext","readFlowCollection","captureStart","folding","tmp","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockScalar","captureEnd","readSingleQuotedScalar","hexLength","hexResult","readDoubleQuotedScalar","readAlias","withinFlowCollection","hasPendingContent","_lineIndent","_kind","readPlainScalar","readDocument","directiveName","directiveArgs","documentStart","hasDirectives","loadDocuments","nullpos","loader","loadAll","iterator","load","_toString$2","_hasOwnProperty$3","CHAR_BOM","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","encodeHex","character","State$1","noArrayIndent","skipInvalid","flowLevel","styleMap","compileStyleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","next","generateNextLine","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","codePointAt","first","needIndentIndicator","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","isPlainSafeLast","writeScalar","iskey","dump","testImplicitResolving","blockHeader","dropEndingNewline","width","moreIndented","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","foldString","escapeSeq","escapeString","indentIndicator","clip","breakRe","curr","writeBlockSequence","writeNode","detectType","isblockseq","tagStr","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","writeFlowSequence","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","renamed","from","to","jsYaml","Type","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SCHEMA","safeLoad","safeLoadAll","safeDump","cb","marker_str","marker_char","marker_len","nextLine","marker_count","old_parent","old_line_max","start_content","auto_closed","sCount","blkIndent","skipSpaces","parentType","lineMax","hidden","meta","false","true","hasProp","uniqueSlug","slug","slugs","failOnNonUnique","startIndex","uniq","opts","title","acc","attrGet","attrSet","permalink","renderPermalink","linkTokens","Token","attrs","permalinkClass","permalinkHref","entries","permalinkAttrs","permalinkSymbol","permalinkSpace","permalinkBefore","openMarker","openChar","closeMarker","closeChar","render","image","generateSource","umlCode","pluginOptions","imageFormat","diagramName","server","deflate","require","encode64","zip_deflate","unescape","params","autoClosed","closeMarkerMatched","contents","join","altToken","env","info","uml_diagram","out","buff","j","zip_deflate_data","zip_deflate_pos","zip_compr_level","zip_initflag","zip_eofile","zip_outbuf","zip_free_queue","zip_qhead","zip_qtail","zip_OUTBUFSIZ","zip_window","zip_window_size","zip_d_buf","zip_DIST_BUFSIZE","zip_l_buf","zip_INBUFSIZ","zip_prev","zip_dyn_ltree","zip_HEAP_SIZE","zip_DeflateCT","zip_dyn_dtree","zip_static_ltree","zip_L_CODES","zip_static_dtree","zip_D_CODES","zip_bl_tree","zip_l_desc","zip_DeflateTreeDesc","zip_d_desc","zip_bl_desc","zip_bl_count","zip_MAX_BITS","zip_heap","zip_depth","zip_length_code","zip_MAX_MATCH","zip_dist_code","zip_base_length","zip_base_dist","zip_flag_buf","zip_LIT_BUFSIZE","zip_deflate_start","zip_deflate_internal","r","append3bytes","zip_outcnt","zip_outoff","zip_complete","zip_bi_buf","zip_bi_valid","zip_block_start","zip_ins_h","zip_hash_head","zip_prev_match","zip_match_available","zip_match_length","zip_prev_length","zip_strstart","zip_match_start","zip_lookahead","zip_max_chain_length","zip_max_lazy_match","zip_good_match","zip_heap_len","zip_heap_max","zip_last_lit","zip_last_dist","zip_last_flags","zip_flags","zip_flag_bit","zip_opt_len","zip_static_len","zip_WSIZE","zip_HASH_SIZE","zip_HASH_MASK","zip_MIN_LOOKAHEAD","zip_MAX_DIST","zip_LITERALS","zip_BL_CODES","zip_H_SHIFT","zip_extra_lbits","zip_extra_dbits","zip_extra_blbits","zip_bl_order","zip_configuration_table","zip_DeflateConfiguration","fc","dl","dyn_tree","static_tree","extra_bits","extra_base","elems","max_length","max_code","a","b","d","good_length","max_lazy","nice_length","max_chain","zip_DeflateBuffer","len","ptr","off","zip_reuse_queue","p","zip_head1","zip_head2","val","zip_put_byte","q","zip_new_queue","zip_qoutbuf","zip_put_short","w","zip_INSERT_STRING","zip_SEND_CODE","zip_send_bits","zip_D_CODE","dist","zip_SMALLER","m","zip_read_buff","offset","zip_longest_match","cur_match","matchp","chain_length","scanp","best_len","limit","strendp","scan_end1","scan_end","zip_fill_window","more","zip_init_deflate","zip_LENGTH_CODES","zip_gen_codes","zip_bi_reverse","zip_init_block","zip_ct_init","zip_MIN_MATCH","zip_lm_init","buff_size","zip_qcopy","flush","zip_ct_tally","zip_flush_block","zip_deflate_fast","zip_deflate_better","zip_pqdownheap","k","v","next_code","zip_build_tree","desc","stree","xnew","h","xbits","f","extra","base","overflow","zip_gen_bitlen","zip_scan_tree","curlen","prevlen","nextlen","max_count","min_count","zip_send_tree","eof","opt_lenb","static_lenb","max_blindex","stored_len","zip_build_bl_tree","zip_bi_windup","zip_compress_block","lcodes","dcodes","blcodes","rank","zip_send_all_trees","dcode","out_length","in_length","ltree","dtree","lx","dx","fx","flag","b1","b2","b3","c2","c3","c4","encode6bit","modules","__webpack_require__","get","_toConsumableArray","arr","arr2","rendererRule","coreRuler","regex","newTokens","item","newToken","default","property","receiver","Reflect","getPrototypeOf","getOwnPropertyDescriptor","useResizeObserver","onResize","onResizeRef","useRef","current","resizeObserverRef","_useState","useState","height","size","setSize","didUnmount","useEffect","previous","refCallback","subscriber","refOrElement","_ref","ref","refElement","callbackRefElement","useCallback","element","callSubscriber","lastReportedElementRef","cleanupRef","HTMLElement","useResolvedElement","ResizeObserver","entry","newWidth","round","contentRect","newHeight","newSize","observe","unobserve","useMemo"],"mappings":"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","file":"static/js/18.689c1111.chunk.js","sourcesContent":[";(function (root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory()\n  } else {\n    root.markdownitMathjax = factory()\n  }\n})(this, function () {\n  function math (state, silent) {\n    var startMathPos = state.pos\n    if (state.src.charCodeAt(startMathPos) !== 0x5C /* \\ */) {\n      return false\n    }\n    var match = state.src.slice(++startMathPos).match(/^(?:\\\\\\[|\\\\\\(|begin\\{([^}]*)\\})/)\n    if (!match) {\n      return false\n    }\n    startMathPos += match[0].length\n    var type, endMarker, includeMarkers\n    if (match[0] === '\\\\[') {\n      type = 'display_math'\n      endMarker = '\\\\\\\\]'\n    } else if (match[0] === '\\\\(') {\n      type = 'inline_math'\n      endMarker = '\\\\\\\\)'\n    } else if (match[1]) {\n      type = 'math'\n      endMarker = '\\\\end{' + match[1] + '}'\n      includeMarkers = true\n    }\n    var endMarkerPos = state.src.indexOf(endMarker, startMathPos)\n    if (endMarkerPos === -1) {\n      return false\n    }\n    var nextPos = endMarkerPos + endMarker.length\n    if (!silent) {\n      var token = state.push(type, '', 0)\n      token.content = includeMarkers\n        ? state.src.slice(state.pos, nextPos)\n        : state.src.slice(startMathPos, endMarkerPos)\n    }\n    state.pos = nextPos\n    return true\n  }\n\n  function texMath (state, silent) {\n    var startMathPos = state.pos\n    if (state.src.charCodeAt(startMathPos) !== 0x24 /* $ */) {\n      return false\n    }\n\n    // Parse tex math according to http://pandoc.org/README.html#math\n    var endMarker = '$'\n    var afterStartMarker = state.src.charCodeAt(++startMathPos)\n    if (afterStartMarker === 0x24 /* $ */) {\n      endMarker = '$$'\n      if (state.src.charCodeAt(++startMathPos) === 0x24 /* $ */) {\n        // 3 markers are too much\n        return false\n      }\n    } else {\n      // Skip if opening $ is succeeded by a space character\n      if (afterStartMarker === 0x20 /* space */ || afterStartMarker === 0x09 /* \\t */ || afterStartMarker === 0x0a /* \\n */) {\n        return false\n      }\n    }\n    var endMarkerPos = state.src.indexOf(endMarker, startMathPos)\n    if (endMarkerPos === -1) {\n      return false\n    }\n    if (state.src.charCodeAt(endMarkerPos - 1) === 0x5C /* \\ */) {\n      return false\n    }\n    var nextPos = endMarkerPos + endMarker.length\n    if (endMarker.length === 1) {\n      // Skip if $ is preceded by a space character\n      var beforeEndMarker = state.src.charCodeAt(endMarkerPos - 1)\n      if (beforeEndMarker === 0x20 /* space */ || beforeEndMarker === 0x09 /* \\t */ || beforeEndMarker === 0x0a /* \\n */) {\n        return false\n      }\n      // Skip if closing $ is succeeded by a digit (eg $5 $10 ...)\n      var suffix = state.src.charCodeAt(nextPos)\n      if (suffix >= 0x30 && suffix < 0x3A) {\n        return false\n      }\n    }\n\n    if (!silent) {\n      var token = state.push(endMarker.length === 1 ? 'inline_math' : 'display_math', '', 0)\n      token.content = state.src.slice(startMathPos, endMarkerPos)\n    }\n    state.pos = nextPos\n    return true\n  }\n\n  function escapeHtml (html) {\n    return html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ')\n  }\n\n  function extend (options, defaults) {\n    return Object.keys(defaults).reduce(function (result, key) {\n      if (result[key] === undefined) {\n        result[key] = defaults[key]\n      }\n      return result\n    }, options)\n  }\n\n  var mapping = {\n    'math': 'Math',\n    'inline_math': 'InlineMath',\n    'display_math': 'DisplayMath'\n  }\n\n  return function (options) {\n    var defaults = {\n      beforeMath: '',\n      afterMath: '',\n      beforeInlineMath: '\\\\(',\n      afterInlineMath: '\\\\)',\n      beforeDisplayMath: '\\\\[',\n      afterDisplayMath: '\\\\]'\n    }\n    options = extend(options || {}, defaults)\n\n    return function (md) {\n      md.inline.ruler.before('escape', 'math', math)\n      md.inline.ruler.push('texMath', texMath)\n\n      Object.keys(mapping).forEach(function (key) {\n        var before = options['before' + mapping[key]]\n        var after = options['after' + mapping[key]]\n        md.renderer.rules[key] = function (tokens, idx) {\n          return before + escapeHtml(tokens[idx].content) + after\n        }\n      })\n    }\n  }\n})\n","const slugify = (s) => encodeURIComponent(String(s).trim().toLowerCase().replace(/\\s+/g, '-'))\n\nconst position = {\n  false: 'push',\n  true: 'unshift'\n}\n\nconst hasProp = Object.prototype.hasOwnProperty\n\nconst permalinkHref = slug => `#${slug}`\nconst permalinkAttrs = slug => ({})\n\nconst renderPermalink = (slug, opts, state, idx) => {\n  const space = () => Object.assign(new state.Token('text', '', 0), { content: ' ' })\n\n  const linkTokens = [\n    Object.assign(new state.Token('link_open', 'a', 1), {\n      attrs: [\n        ...(opts.permalinkClass ? [['class', opts.permalinkClass]] : []),\n        ['href', opts.permalinkHref(slug, state)],\n        ...Object.entries(opts.permalinkAttrs(slug, state))\n      ]\n    }),\n    Object.assign(new state.Token('html_block', '', 0), { content: opts.permalinkSymbol }),\n    new state.Token('link_close', 'a', -1)\n  ]\n\n  // `push` or `unshift` according to position option.\n  // Space is at the opposite side.\n  if (opts.permalinkSpace) {\n    linkTokens[position[!opts.permalinkBefore]](space())\n  }\n  state.tokens[idx + 1].children[position[opts.permalinkBefore]](...linkTokens)\n}\n\nconst uniqueSlug = (slug, slugs, failOnNonUnique, startIndex) => {\n  let uniq = slug\n  let i = startIndex\n  if (failOnNonUnique && hasProp.call(slugs, uniq)) {\n    throw Error(`User defined id attribute '${slug}' is NOT unique. Please fix it in your markdown to continue.`)\n  } else {\n    while (hasProp.call(slugs, uniq)) uniq = `${slug}-${i++}`\n  }\n  slugs[uniq] = true\n  return uniq\n}\n\nconst isLevelSelectedNumber = selection => level => level >= selection\nconst isLevelSelectedArray = selection => level => selection.includes(level)\n\nconst anchor = (md, opts) => {\n  opts = Object.assign({}, anchor.defaults, opts)\n\n  md.core.ruler.push('anchor', state => {\n    const slugs = {}\n    const tokens = state.tokens\n\n    const isLevelSelected = Array.isArray(opts.level)\n      ? isLevelSelectedArray(opts.level)\n      : isLevelSelectedNumber(opts.level)\n\n    tokens\n      .filter(token => token.type === 'heading_open')\n      .filter(token => isLevelSelected(Number(token.tag.substr(1))))\n      .forEach(token => {\n        // Aggregate the next token children text.\n        const title = tokens[tokens.indexOf(token) + 1]\n          .children\n          .filter(token => token.type === 'text' || token.type === 'code_inline')\n          .reduce((acc, t) => acc + t.content, '')\n\n        let slug = token.attrGet('id')\n\n        if (slug == null) {\n          slug = uniqueSlug(opts.slugify(title), slugs, false, opts.uniqueSlugStartIndex)\n        } else {\n          slug = uniqueSlug(slug, slugs, true, opts.uniqueSlugStartIndex)\n        }\n        token.attrSet('id', slug)\n\n        if (opts.permalink) {\n          opts.renderPermalink(slug, opts, state, tokens.indexOf(token))\n        }\n\n        if (opts.callback) {\n          opts.callback(token, { slug, title })\n        }\n      })\n  })\n}\n\nanchor.defaults = {\n  level: 1,\n  slugify,\n  uniqueSlugStartIndex: 1,\n  permalink: false,\n  renderPermalink,\n  permalinkClass: 'header-anchor',\n  permalinkSpace: true,\n  permalinkSymbol: '¶',\n  permalinkBefore: false,\n  permalinkHref,\n  permalinkAttrs\n}\n\nexport default anchor\n","\n/*! js-yaml 4.0.0 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nvar isNothing_1      = isNothing;\nvar isObject_1       = isObject;\nvar toArray_1        = toArray;\nvar repeat_1         = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1         = extend;\n\nvar common = {\n\tisNothing: isNothing_1,\n\tisObject: isObject_1,\n\ttoArray: toArray_1,\n\trepeat: repeat_1,\n\tisNegativeZero: isNegativeZero_1,\n\textend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nvar exception = YAMLException;\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '→') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nvar snippet = makeSnippet;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type;\n\n/*eslint-disable max-len*/\n\n\n\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit', []);\n  result.compiledExplicit = compileList(result, 'explicit', []);\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nvar schema = Schema;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\n\nvar core = json;\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n/*eslint-disable no-bitwise*/\n\n\n\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$1.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || _default;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = snippet(mark);\n\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$2.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$2.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty$2.call(overridableKeys, keyNode) &&\n        _hasOwnProperty$2.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$2.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception('expected a single document in the stream, but found more');\n}\n\n\nvar loadAll_1 = loadAll;\nvar load_1    = load;\n\nvar loader = {\n\tloadAll: loadAll_1,\n\tload: load_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\n\n\n\nvar _toString$2       = Object.prototype.toString;\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State$1(options) {\n  this.schema        = options['schema'] || _default;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString$2.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty$3.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString$2.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State$1(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nvar dump_1 = dump;\n\nvar dumper = {\n\tdump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nvar Type$1                = type;\nvar Schema$1              = schema;\nvar FAILSAFE_SCHEMA     = failsafe;\nvar JSON_SCHEMA         = json;\nvar CORE_SCHEMA         = core;\nvar DEFAULT_SCHEMA      = _default;\nvar load$1                = loader.load;\nvar loadAll$1             = loader.loadAll;\nvar dump$1                = dumper.dump;\nvar YAMLException$1       = exception;\n\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad            = renamed('safeLoad', 'load');\nvar safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nvar safeDump            = renamed('safeDump', 'dump');\n\nvar jsYaml = {\n\tType: Type$1,\n\tSchema: Schema$1,\n\tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n\tJSON_SCHEMA: JSON_SCHEMA,\n\tCORE_SCHEMA: CORE_SCHEMA,\n\tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n\tload: load$1,\n\tloadAll: loadAll$1,\n\tdump: dump$1,\n\tYAMLException: YAMLException$1,\n\tsafeLoad: safeLoad,\n\tsafeLoadAll: safeLoadAll,\n\tsafeDump: safeDump\n};\n\nexport default jsYaml;\nexport { CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema$1 as Schema, Type$1 as Type, YAMLException$1 as YAMLException, dump$1 as dump, load$1 as load, loadAll$1 as loadAll, safeDump, safeLoad, safeLoadAll };\n","// Process front matter and pass to cb\n'use strict';\n\nmodule.exports = function front_matter_plugin(md, cb) {\n  var min_markers = 3,\n      marker_str  = '-',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length;\n\n  function frontMatter(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        token,\n        old_parent,\n        old_line_max,\n        start_content,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character of the first line quickly,\n    // this should filter out non-front matter\n    if (startLine !== 0 || marker_char !== state.src.charCodeAt(0)) {\n      return false;\n    }\n\n    // Check out the rest of the marker string\n    // while pos <= 3\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        start_content = pos + 1;\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n    pos -= (pos - start) % marker_len;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) {\n      return true;\n    }\n\n    // Search for the end of the block\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      if (state.src.slice(start, max) === '...') {\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('front_matter', null, 0);\n    token.hidden = true;\n    token.markup = state.src.slice(startLine, pos);\n    token.block  = true;\n    token.map    = [ startLine, pos ];\n    token.meta   = state.src.slice(start_content, start - 1);\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    cb(token.meta);\n\n    return true;\n  }\n\n  md.block.ruler.before(\n    'table',\n    'front_matter',\n    frontMatter,\n    {\n      alt: [\n        'paragraph',\n        'reference',\n        'blockquote',\n        'list' \n      ]\n    }\n  );\n};\n","// Process block-level uml diagrams\n//\n'use strict';\n\nmodule.exports = function umlPlugin(md, options) {\n\n  function generateSourceDefault(umlCode, pluginOptions) {\n    var imageFormat = pluginOptions.imageFormat || 'svg';\n    var diagramName = pluginOptions.diagramName || 'uml';\n    var server = pluginOptions.server || 'https://www.plantuml.com/plantuml';\n    var deflate = require('./lib/deflate.js');\n    var zippedCode = deflate.encode64(\n      deflate.zip_deflate(\n        unescape(encodeURIComponent(\n          '@start' + diagramName + '\\n' + umlCode + '\\n@end' + diagramName)),\n        9\n      )\n    );\n\n    return server + '/' + imageFormat + '/' + zippedCode;\n  }\n\n  options = options || {};\n\n  var openMarker = options.openMarker || '@startuml',\n      openChar = openMarker.charCodeAt(0),\n      closeMarker = options.closeMarker || '@enduml',\n      closeChar = closeMarker.charCodeAt(0),\n      render = options.render || md.renderer.rules.image,\n      generateSource = options.generateSource || generateSourceDefault;\n\n  function uml(state, startLine, endLine, silent) {\n    var nextLine, markup, params, token, i,\n        autoClosed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-uml blocks\n    //\n    if (openChar !== state.src.charCodeAt(start)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (i = 0; i < openMarker.length; ++i) {\n      if (openMarker[i] !== state.src[start + i]) { return false; }\n    }\n\n    markup = state.src.slice(start, start + i);\n    params = state.src.slice(start + i, max);\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (closeChar !== state.src.charCodeAt(start)) {\n        // didn't find the closing fence\n        continue;\n      }\n\n      if (state.sCount[nextLine] > state.sCount[startLine]) {\n        // closing fence should not be indented with respect of opening fence\n        continue;\n      }\n\n      var closeMarkerMatched = true;\n      for (i = 0; i < closeMarker.length; ++i) {\n        if (closeMarker[i] !== state.src[start + i]) {\n          closeMarkerMatched = false;\n          break;\n        }\n      }\n\n      if (!closeMarkerMatched) {\n        continue;\n      }\n\n      // make sure tail has spaces only\n      if (state.skipSpaces(start + i) < max) {\n        continue;\n      }\n\n      // found!\n      autoClosed = true;\n      break;\n    }\n\n    var contents = state.src\n      .split('\\n')\n      .slice(startLine + 1, nextLine)\n      .join('\\n');\n\n    // We generate a token list for the alt property, to mimic what the image parser does.\n    var altToken = [];\n    // Remove leading space if any.\n    var alt = params ? params.slice(1) : 'uml diagram';\n    state.md.inline.parse(\n      alt,\n      state.md,\n      state.env,\n      altToken\n    );\n\n    token = state.push('uml_diagram', 'img', 0);\n    // alt is constructed from children. No point in populating it here.\n    token.attrs = [ [ 'src', generateSource(contents, options) ], [ 'alt', '' ] ];\n    token.block = true;\n    token.children = altToken;\n    token.info = params;\n    token.map = [ startLine, nextLine ];\n    token.markup = markup;\n\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'uml_diagram', uml, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n  md.renderer.rules.uml_diagram = render;\n};\n","// Using this library so that our img links are compatible with plantUml website.\n// TODO: replace this library with zlib once we create our private uml server.\n\n'use strict';\n\n// Added to original:\nmodule.exports = {\n  zip_deflate: zip_deflate,\n  encode64: encode64\n};\n\n// Original[some parts modified to avoid errors]:\n\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = zip_deflate(src);\n */\n\n/* constant parameters */\nvar zip_WSIZE = 32768;\t\t// Sliding Window size\nvar zip_STORED_BLOCK = 0;\nvar zip_STATIC_TREES = 1;\nvar zip_DYN_TREES    = 2;\n\n/* for deflate */\nvar zip_DEFAULT_LEVEL = 6;\nvar zip_FULL_SEARCH = true;\nvar zip_INBUFSIZ = 32768;\t// Input buffer size\nvar zip_INBUF_EXTRA = 64;\t// Extra buffer\nvar zip_OUTBUFSIZ = 1024 * 8;\nvar zip_window_size = 2 * zip_WSIZE;\nvar zip_MIN_MATCH = 3;\nvar zip_MAX_MATCH = 258;\nvar zip_BITS = 16;\n// for SMALL_MEM\nvar zip_LIT_BUFSIZE = 0x2000;\nvar zip_HASH_BITS = 13;\n// for MEDIUM_MEM\n// var zip_LIT_BUFSIZE = 0x4000;\n// var zip_HASH_BITS = 14;\n// for BIG_MEM\n// var zip_LIT_BUFSIZE = 0x8000;\n// var zip_HASH_BITS = 15;\n// if (zip_LIT_BUFSIZE > zip_INBUFSIZ) { alert('error: zip_INBUFSIZ is too small'); }\n// if ((zip_WSIZE << 1) > (1 << zip_BITS)) { alert('error: zip_WSIZE is too large'); }\n// if (zip_HASH_BITS > zip_BITS - 1) { alert('error: zip_HASH_BITS is too large'); }\n// if (zip_HASH_BITS < 8 || zip_MAX_MATCH != 258) { alert('error: Code too clever'); }\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\nvar zip_WMASK = zip_WSIZE - 1;\nvar zip_NIL = 0; // Tail of hash chains\nvar zip_TOO_FAR = 4096;\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\nvar zip_SMALLEST = 1;\nvar zip_MAX_BITS = 15;\nvar zip_MAX_BL_BITS = 7;\nvar zip_LENGTH_CODES = 29;\nvar zip_LITERALS = 256;\nvar zip_END_BLOCK = 256;\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\nvar zip_D_CODES = 30;\nvar zip_BL_CODES = 19;\nvar zip_REP_3_6 = 16;\nvar zip_REPZ_3_10 = 17;\nvar zip_REPZ_11_138 = 18;\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\n  zip_MIN_MATCH);\n\n/* variables */\nvar zip_free_queue;\nvar zip_qhead, zip_qtail;\nvar zip_initflag;\nvar zip_outbuf = null;\nvar zip_outcnt, zip_outoff;\nvar zip_complete;\nvar zip_window;\nvar zip_d_buf;\nvar zip_l_buf;\nvar zip_prev;\nvar zip_bi_buf;\nvar zip_bi_valid;\nvar zip_block_start;\nvar zip_ins_h;\nvar zip_hash_head;\nvar zip_prev_match;\nvar zip_match_available;\nvar zip_match_length;\nvar zip_prev_length;\nvar zip_strstart;\nvar zip_match_start;\nvar zip_eofile;\nvar zip_lookahead;\nvar zip_max_chain_length;\nvar zip_max_lazy_match;\nvar zip_compr_level;\nvar zip_good_match;\nvar zip_nice_match;\nvar zip_dyn_ltree;\nvar zip_dyn_dtree;\nvar zip_static_ltree;\nvar zip_static_dtree;\nvar zip_bl_tree;\nvar zip_l_desc;\nvar zip_d_desc;\nvar zip_bl_desc;\nvar zip_bl_count;\nvar zip_heap;\nvar zip_heap_len;\nvar zip_heap_max;\nvar zip_depth;\nvar zip_length_code;\nvar zip_dist_code;\nvar zip_base_length;\nvar zip_base_dist;\nvar zip_flag_buf;\nvar zip_last_lit;\nvar zip_last_dist;\nvar zip_last_flags;\nvar zip_flags;\nvar zip_flag_bit;\nvar zip_opt_len;\nvar zip_static_len;\nvar zip_deflate_data;\nvar zip_deflate_pos;\n\n/* constant tables */\nvar zip_extra_lbits = new Array(\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0);\nvar zip_extra_dbits = new Array(\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13);\nvar zip_extra_blbits = new Array(\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7);\nvar zip_bl_order = new Array(\n  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);\nvar zip_configuration_table = new Array(\n  new zip_DeflateConfiguration(0,    0,   0,    0),\n  new zip_DeflateConfiguration(4,    4,   8,    4),\n  new zip_DeflateConfiguration(4,    5,  16,    8),\n  new zip_DeflateConfiguration(4,    6,  32,   32),\n  new zip_DeflateConfiguration(4,    4,  16,   16),\n  new zip_DeflateConfiguration(8,   16,  32,   32),\n  new zip_DeflateConfiguration(8,   16, 128,  128),\n  new zip_DeflateConfiguration(8,   32, 128,  256),\n  new zip_DeflateConfiguration(32, 128, 258, 1024),\n  new zip_DeflateConfiguration(32, 258, 258, 4096));\n\n/* objects (deflate) */\n\nfunction zip_DeflateCT() {\n  this.fc = 0; // frequency count or bit string\n  this.dl = 0; // father node in Huffman tree or length of bit string\n}\n\nfunction zip_DeflateTreeDesc() {\n  this.dyn_tree = null;\t// the dynamic tree\n  this.static_tree = null;\t// corresponding static tree or NULL\n  this.extra_bits = null;\t// extra bits for each code or NULL\n  this.extra_base = 0;\t// base index for extra_bits\n  this.elems = 0;\t\t// max number of elements in the tree\n  this.max_length = 0;\t// max bit length for the codes\n  this.max_code = 0;\t\t// largest code with non zero frequency\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction zip_DeflateConfiguration(a, b, c, d) {\n  this.good_length = a; // reduce lazy search above this match length\n  this.max_lazy = b;    // do not perform lazy search above this match length\n  this.nice_length = c; // quit search above this match length\n  this.max_chain = d;\n}\n\nfunction zip_DeflateBuffer() {\n  this.next = null;\n  this.len = 0;\n  this.ptr = new Array(zip_OUTBUFSIZ);\n  this.off = 0;\n}\n\n/* routines (deflate) */\n\nfunction zip_deflate_start(level) {\n  var i;\n\n  if (!level) { level = zip_DEFAULT_LEVEL; } else if (level < 1) { level = 1; } else if (level > 9) { level = 9; }\n\n  zip_compr_level = level;\n  zip_initflag = false;\n  zip_eofile = false;\n  if (zip_outbuf != null) { return; }\n\n  zip_free_queue = zip_qhead = zip_qtail = null;\n  zip_outbuf = new Array(zip_OUTBUFSIZ);\n  zip_window = new Array(zip_window_size);\n  zip_d_buf = new Array(zip_DIST_BUFSIZE);\n  zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\n  zip_prev = new Array(1 << zip_BITS);\n  zip_dyn_ltree = new Array(zip_HEAP_SIZE);\n  for (i = 0; i < zip_HEAP_SIZE; i++) { zip_dyn_ltree[i] = new zip_DeflateCT(); }\n  zip_dyn_dtree = new Array(2 * zip_D_CODES + 1);\n  for (i = 0; i < 2 * zip_D_CODES + 1; i++) { zip_dyn_dtree[i] = new zip_DeflateCT(); }\n  zip_static_ltree = new Array(zip_L_CODES + 2);\n  for (i = 0; i < zip_L_CODES + 2; i++) { zip_static_ltree[i] = new zip_DeflateCT(); }\n  zip_static_dtree = new Array(zip_D_CODES);\n  for (i = 0; i < zip_D_CODES; i++) { zip_static_dtree[i] = new zip_DeflateCT(); }\n  zip_bl_tree = new Array(2 * zip_BL_CODES + 1);\n  for (i = 0; i < 2 * zip_BL_CODES + 1; i++) { zip_bl_tree[i] = new zip_DeflateCT(); }\n  zip_l_desc = new zip_DeflateTreeDesc();\n  zip_d_desc = new zip_DeflateTreeDesc();\n  zip_bl_desc = new zip_DeflateTreeDesc();\n  zip_bl_count = new Array(zip_MAX_BITS + 1);\n  zip_heap = new Array(2 * zip_L_CODES + 1);\n  zip_depth = new Array(2 * zip_L_CODES + 1);\n  zip_length_code = new Array(zip_MAX_MATCH - zip_MIN_MATCH + 1);\n  zip_dist_code = new Array(512);\n  zip_base_length = new Array(zip_LENGTH_CODES);\n  zip_base_dist = new Array(zip_D_CODES);\n  zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\n}\n\nfunction zip_deflate_end() {\n  zip_free_queue = zip_qhead = zip_qtail = null;\n  zip_outbuf = null;\n  zip_window = null;\n  zip_d_buf = null;\n  zip_l_buf = null;\n  zip_prev = null;\n  zip_dyn_ltree = null;\n  zip_dyn_dtree = null;\n  zip_static_ltree = null;\n  zip_static_dtree = null;\n  zip_bl_tree = null;\n  zip_l_desc = null;\n  zip_d_desc = null;\n  zip_bl_desc = null;\n  zip_bl_count = null;\n  zip_heap = null;\n  zip_depth = null;\n  zip_length_code = null;\n  zip_dist_code = null;\n  zip_base_length = null;\n  zip_base_dist = null;\n  zip_flag_buf = null;\n}\n\nfunction zip_reuse_queue(p) {\n  p.next = zip_free_queue;\n  zip_free_queue = p;\n}\n\nfunction zip_new_queue() {\n  var p;\n\n  if (zip_free_queue != null) {\n    p = zip_free_queue;\n    zip_free_queue = zip_free_queue.next;\n  } else { p = new zip_DeflateBuffer(); }\n  p.next = null;\n  p.len = p.off = 0;\n\n  return p;\n}\n\nfunction zip_head1(i) {\n  return zip_prev[zip_WSIZE + i];\n}\n\nfunction zip_head2(i, val) {\n  return zip_prev[zip_WSIZE + i] = val;\n}\n\n/* put_byte is used for the compressed output, put_ubyte for the\n * uncompressed output. However unlzw() uses window for its\n * suffix table instead of its output buffer, so it does not use put_ubyte\n * (to be cleaned up).\n */\nfunction zip_put_byte(c) {\n  zip_outbuf[zip_outoff + zip_outcnt++] = c;\n  if (zip_outoff + zip_outcnt == zip_OUTBUFSIZ) { zip_qoutbuf(); }\n}\n\n/* Output a 16 bit value, lsb first */\nfunction zip_put_short(w) {\n  w &= 0xffff;\n  if (zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\n    zip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\n    zip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\n  } else {\n    zip_put_byte(w & 0xff);\n    zip_put_byte(w >>> 8);\n  }\n}\n\n/* ==========================================================================\n * Insert string s in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of s are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\nfunction zip_INSERT_STRING() {\n  zip_ins_h = ((zip_ins_h << zip_H_SHIFT)\n    ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\n    & zip_HASH_MASK;\n  zip_hash_head = zip_head1(zip_ins_h);\n  zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\n  zip_head2(zip_ins_h, zip_strstart);\n}\n\n/* Send a code of the given tree. c and tree must not have side effects */\nfunction zip_SEND_CODE(c, tree) {\n  zip_send_bits(tree[c].fc, tree[c].dl);\n}\n\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. dist_code[256] and dist_code[257] are never\n * used.\n */\nfunction zip_D_CODE(dist) {\n  return (dist < 256 ? zip_dist_code[dist]\n    : zip_dist_code[256 + (dist >> 7)]) & 0xff;\n}\n\n/* ==========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction zip_SMALLER(tree, n, m) {\n  return tree[n].fc < tree[m].fc ||\n    (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);\n}\n\n/* ==========================================================================\n * read string data\n */\nfunction zip_read_buff(buff, offset, n) {\n  var i;\n  for (i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++) {\n    buff[offset + i] =\n      zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\n  }\n  return i;\n}\n\n/* ==========================================================================\n * Initialize the \"longest match\" routines for a new file\n */\nfunction zip_lm_init() {\n  var j;\n\n  /* Initialize the hash table. */\n  for (j = 0; j < zip_HASH_SIZE; j++)\n  //\tzip_head2(j, zip_NIL);\n  { zip_prev[zip_WSIZE + j] = 0; }\n  /* prev will be initialized on the fly */\n\n  /* Set the default configuration parameters:\n  */\n  zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\n  zip_good_match     = zip_configuration_table[zip_compr_level].good_length;\n  if (!zip_FULL_SEARCH) { zip_nice_match = zip_configuration_table[zip_compr_level].nice_length; }\n  zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\n\n  zip_strstart = 0;\n  zip_block_start = 0;\n\n  zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\n  if (zip_lookahead <= 0) {\n    zip_eofile = true;\n    zip_lookahead = 0;\n    return;\n  }\n  zip_eofile = false;\n  /* Make sure that we always have enough lookahead. This is important\n   * if input comes from a device such as a tty.\n   */\n  while (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile) { zip_fill_window(); }\n\n  /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n   * not important since only literal bytes will be emitted.\n   */\n  zip_ins_h = 0;\n  for (j = 0; j < zip_MIN_MATCH - 1; j++) {\n    //      UPDATE_HASH(ins_h, window[j]);\n    zip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\n  }\n}\n\n/* ==========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n */\nfunction zip_longest_match(cur_match) {\n  var chain_length = zip_max_chain_length; // max hash chain length\n  var scanp = zip_strstart; // current string\n  var matchp;\t\t// matched string\n  var len;\t\t// length of current match\n  var best_len = zip_prev_length;\t// best match length so far\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n  var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\n\n  var strendp = zip_strstart + zip_MAX_MATCH;\n  var scan_end1 = zip_window[scanp + best_len - 1];\n  var scan_end  = zip_window[scanp + best_len];\n\n  /* Do not waste too much time if we already have a good match: */\n  if (zip_prev_length >= zip_good_match) { chain_length >>= 2; }\n\n  //  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n  do {\n    //    Assert(cur_match < encoder->strstart, \"no future\");\n    matchp = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2:\n     */\n    if (zip_window[matchp + best_len]\t!= scan_end  ||\n      zip_window[matchp + best_len - 1]\t!= scan_end1 ||\n      zip_window[matchp]\t\t\t!= zip_window[scanp] ||\n      zip_window[++matchp]\t\t\t!= zip_window[scanp + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scanp += 2;\n    matchp++;\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n    } while (zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      zip_window[++scanp] == zip_window[++matchp] &&\n      scanp < strendp);\n\n    len = zip_MAX_MATCH - (strendp - scanp);\n    scanp = strendp - zip_MAX_MATCH;\n\n    if (len > best_len) {\n      zip_match_start = cur_match;\n      best_len = len;\n      if (zip_FULL_SEARCH) {\n        if (len >= zip_MAX_MATCH) break;\n      } else if (len >= zip_nice_match) break;\n\n      scan_end1  = zip_window[scanp + best_len - 1];\n      scan_end   = zip_window[scanp + best_len];\n    }\n  } while ((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\n    && --chain_length != 0);\n\n  return best_len;\n}\n\n/* ==========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead, and sets eofile if end of input file.\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n * OUT assertions: at least one byte has been read, or eofile is set;\n *    file reads are performed for at least two bytes (required for the\n *    translate_eol option).\n */\nfunction zip_fill_window() {\n  var n, m;\n\n  // Amount of free space at the end of the window.\n  var more = zip_window_size - zip_lookahead - zip_strstart;\n\n  /* If the window is almost full and there is insufficient lookahead,\n   * move the upper half to the lower one to make room in the upper half.\n   */\n  if (more == -1) {\n    /* Very unlikely, but possible on 16 bit machine if strstart == 0\n     * and lookahead == 1 (input done one byte at time)\n     */\n    more--;\n  } else if (zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\n    /* By the IN assertion, the window is not empty so we can't confuse\n     * more == 0 with more == 64K on a 16 bit machine.\n     */\n    //\tAssert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n    //\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\n    for (n = 0; n < zip_WSIZE; n++) { zip_window[n] = zip_window[n + zip_WSIZE]; }\n\n    zip_match_start -= zip_WSIZE;\n    zip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\n    zip_block_start -= zip_WSIZE;\n\n    for (n = 0; n < zip_HASH_SIZE; n++) {\n      m = zip_head1(n);\n      zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n    }\n    for (n = 0; n < zip_WSIZE; n++) {\n      /* If n is not on any hash chain, prev[n] is garbage but\n       * its value will never be used.\n       */\n      m = zip_prev[n];\n      zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n    }\n    more += zip_WSIZE;\n  }\n  // At this point, more >= 2\n  if (!zip_eofile) {\n    n = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\n    if (n <= 0) { zip_eofile = true; } else { zip_lookahead += n; }\n  }\n}\n\n/* ==========================================================================\n * Processes a new input file and return its compressed length. This\n * function does not perform lazy evaluationof matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction zip_deflate_fast() {\n  while (zip_lookahead != 0 && zip_qhead == null) {\n    var flush; // set if current block must be flushed\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    zip_INSERT_STRING();\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (zip_hash_head != zip_NIL &&\n      zip_strstart - zip_hash_head <= zip_MAX_DIST) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      zip_match_length = zip_longest_match(zip_hash_head);\n      /* longest_match() sets match_start */\n      if (zip_match_length > zip_lookahead) { zip_match_length = zip_lookahead; }\n    }\n    if (zip_match_length >= zip_MIN_MATCH) {\n      //\t    check_match(strstart, match_start, match_length);\n\n      flush = zip_ct_tally(zip_strstart - zip_match_start,\n        zip_match_length - zip_MIN_MATCH);\n      zip_lookahead -= zip_match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (zip_match_length <= zip_max_lazy_match) {\n        zip_match_length--; // string at strstart already in hash table\n        do {\n          zip_strstart++;\n          zip_INSERT_STRING();\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n           * these bytes are garbage, but it does not matter since\n           * the next lookahead bytes will be emitted as literals.\n           */\n        } while (--zip_match_length != 0);\n        zip_strstart++;\n      } else {\n        zip_strstart += zip_match_length;\n        zip_match_length = 0;\n        zip_ins_h = zip_window[zip_strstart] & 0xff;\n        //\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\n        zip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\n\n        //#if MIN_MATCH != 3\n        //\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n        //#endif\n\n      }\n    } else {\n      /* No match, output a literal byte */\n      flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\n      zip_lookahead--;\n      zip_strstart++;\n    }\n    if (flush) {\n      zip_flush_block(0);\n      zip_block_start = zip_strstart;\n    }\n\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    while (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile) { zip_fill_window(); }\n  }\n}\n\nfunction zip_deflate_better() {\n  /* Process the input block. */\n  while (zip_lookahead != 0 && zip_qhead == null) {\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    zip_INSERT_STRING();\n\n    /* Find the longest match, discarding those <= prev_length.\n    */\n    zip_prev_length = zip_match_length;\n    zip_prev_match = zip_match_start;\n    zip_match_length = zip_MIN_MATCH - 1;\n\n    if (zip_hash_head != zip_NIL &&\n      zip_prev_length < zip_max_lazy_match &&\n      zip_strstart - zip_hash_head <= zip_MAX_DIST) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      zip_match_length = zip_longest_match(zip_hash_head);\n      /* longest_match() sets match_start */\n      if (zip_match_length > zip_lookahead) { zip_match_length = zip_lookahead; }\n\n      /* Ignore a length 3 match if it is too distant: */\n      if (zip_match_length == zip_MIN_MATCH &&\n        zip_strstart - zip_match_start > zip_TOO_FAR) {\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        zip_match_length--;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (zip_prev_length >= zip_MIN_MATCH &&\n      zip_match_length <= zip_prev_length) {\n      var flush; // set if current block must be flushed\n\n      //\t    check_match(strstart - 1, prev_match, prev_length);\n      flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\n        zip_prev_length - zip_MIN_MATCH);\n\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted.\n       */\n      zip_lookahead -= zip_prev_length - 1;\n      zip_prev_length -= 2;\n      do {\n        zip_strstart++;\n        zip_INSERT_STRING();\n        /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n         * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n         * these bytes are garbage, but it does not matter since the\n         * next lookahead bytes will always be emitted as literals.\n         */\n      } while (--zip_prev_length != 0);\n      zip_match_available = 0;\n      zip_match_length = zip_MIN_MATCH - 1;\n      zip_strstart++;\n      if (flush) {\n        zip_flush_block(0);\n        zip_block_start = zip_strstart;\n      }\n    } else if (zip_match_available != 0) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      if (zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\n        zip_flush_block(0);\n        zip_block_start = zip_strstart;\n      }\n      zip_strstart++;\n      zip_lookahead--;\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      zip_match_available = 1;\n      zip_strstart++;\n      zip_lookahead--;\n    }\n\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    while (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile) { zip_fill_window(); }\n  }\n}\n\nfunction zip_init_deflate() {\n  if (zip_eofile) { return; }\n  zip_bi_buf = 0;\n  zip_bi_valid = 0;\n  zip_ct_init();\n  zip_lm_init();\n\n  zip_qhead = null;\n  zip_outcnt = 0;\n  zip_outoff = 0;\n\n  if (zip_compr_level <= 3) {\n    zip_prev_length = zip_MIN_MATCH - 1;\n    zip_match_length = 0;\n  } else {\n    zip_match_length = zip_MIN_MATCH - 1;\n    zip_match_available = 0;\n  }\n\n  zip_complete = false;\n}\n\n/* ==========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction zip_deflate_internal(buff, off, buff_size) {\n  var n;\n\n  if (!zip_initflag) {\n    zip_init_deflate();\n    zip_initflag = true;\n    if (zip_lookahead == 0) { // empty\n      zip_complete = true;\n      return 0;\n    }\n  }\n\n  if ((n = zip_qcopy(buff, off, buff_size)) == buff_size) { return buff_size; }\n\n  if (zip_complete) { return n; }\n\n  if (zip_compr_level <= 3) // optimized for speed\n  { zip_deflate_fast(); } else { zip_deflate_better(); }\n  if (zip_lookahead == 0) {\n    if (zip_match_available != 0) { zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff); }\n    zip_flush_block(1);\n    zip_complete = true;\n  }\n  return n + zip_qcopy(buff, n + off, buff_size - n);\n}\n\nfunction zip_qcopy(buff, off, buff_size) {\n  var n, i, j;\n\n  n = 0;\n  while (zip_qhead != null && n < buff_size) {\n    i = buff_size - n;\n    if (i > zip_qhead.len) { i = zip_qhead.len; }\n    //      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n    for (j = 0; j < i; j++) { buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j]; }\n\n    zip_qhead.off += i;\n    zip_qhead.len -= i;\n    n += i;\n    if (zip_qhead.len == 0) {\n      var p;\n      p = zip_qhead;\n      zip_qhead = zip_qhead.next;\n      zip_reuse_queue(p);\n    }\n  }\n\n  if (n == buff_size) { return n; }\n\n  if (zip_outoff < zip_outcnt) {\n    i = buff_size - n;\n    if (i > zip_outcnt - zip_outoff) { i = zip_outcnt - zip_outoff; }\n    // System.arraycopy(outbuf, outoff, buff, off + n, i);\n    for (j = 0; j < i; j++) { buff[off + n + j] = zip_outbuf[zip_outoff + j]; }\n    zip_outoff += i;\n    n += i;\n    if (zip_outcnt == zip_outoff) { zip_outcnt = zip_outoff = 0; }\n  }\n  return n;\n}\n\n/* ==========================================================================\n * Allocate the match buffer, initialize the various tables and save the\n * location of the internal file attribute (ascii/binary) and method\n * (DEFLATE/STORE).\n */\nfunction zip_ct_init() {\n  var n;\t// iterates over tree elements\n  var bits;\t// bit counter\n  var length;\t// length value\n  var code;\t// code value\n  var dist;\t// distance index\n\n  if (zip_static_dtree[0].dl != 0) return; // ct_init already called\n\n  zip_l_desc.dyn_tree\t\t= zip_dyn_ltree;\n  zip_l_desc.static_tree\t= zip_static_ltree;\n  zip_l_desc.extra_bits\t= zip_extra_lbits;\n  zip_l_desc.extra_base\t= zip_LITERALS + 1;\n  zip_l_desc.elems\t\t= zip_L_CODES;\n  zip_l_desc.max_length\t= zip_MAX_BITS;\n  zip_l_desc.max_code\t\t= 0;\n\n  zip_d_desc.dyn_tree\t\t= zip_dyn_dtree;\n  zip_d_desc.static_tree\t= zip_static_dtree;\n  zip_d_desc.extra_bits\t= zip_extra_dbits;\n  zip_d_desc.extra_base\t= 0;\n  zip_d_desc.elems\t\t= zip_D_CODES;\n  zip_d_desc.max_length\t= zip_MAX_BITS;\n  zip_d_desc.max_code\t\t= 0;\n\n  zip_bl_desc.dyn_tree\t= zip_bl_tree;\n  zip_bl_desc.static_tree\t= null;\n  zip_bl_desc.extra_bits\t= zip_extra_blbits;\n  zip_bl_desc.extra_base\t= 0;\n  zip_bl_desc.elems\t\t= zip_BL_CODES;\n  zip_bl_desc.max_length\t= zip_MAX_BL_BITS;\n  zip_bl_desc.max_code\t= 0;\n\n  // Initialize the mapping length (0..255) -> length code (0..28)\n  length = 0;\n  for (code = 0; code < zip_LENGTH_CODES - 1; code++) {\n    zip_base_length[code] = length;\n    for (n = 0; n < (1 << zip_extra_lbits[code]); n++) { zip_length_code[length++] = code; }\n  }\n  // Assert (length == 256, \"ct_init: length != 256\");\n\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  zip_length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    zip_base_dist[code] = dist;\n    for (n = 0; n < (1 << zip_extra_dbits[code]); n++) {\n      zip_dist_code[dist++] = code;\n    }\n  }\n  // Assert (dist == 256, \"ct_init: dist != 256\");\n  dist >>= 7; // from now on, all distances are divided by 128\n  for (; code < zip_D_CODES; code++) {\n    zip_base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (zip_extra_dbits[code] - 7)); n++) { zip_dist_code[256 + dist++] = code; }\n  }\n  // Assert (dist == 256, \"ct_init: 256+dist != 512\");\n\n  // Construct the codes of the static literal tree\n  for (bits = 0; bits <= zip_MAX_BITS; bits++) { zip_bl_count[bits] = 0; }\n  n = 0;\n  while (n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n  while (n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\n  while (n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\n  while (n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < zip_D_CODES; n++) {\n    zip_static_dtree[n].dl = 5;\n    zip_static_dtree[n].fc = zip_bi_reverse(n, 5);\n  }\n\n  // Initialize the first block of the first file:\n  zip_init_block();\n}\n\n/* ==========================================================================\n * Initialize a new block.\n */\nfunction zip_init_block() {\n  var n; // iterates over tree elements\n\n  // Initialize the trees.\n  for (n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;\n  for (n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;\n  for (n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\n\n  zip_dyn_ltree[zip_END_BLOCK].fc = 1;\n  zip_opt_len = zip_static_len = 0;\n  zip_last_lit = zip_last_dist = zip_last_flags = 0;\n  zip_flags = 0;\n  zip_flag_bit = 1;\n}\n\n/* ==========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction zip_pqdownheap(\n  tree,\t// the tree to restore\n  k) {\t// node to move down\n  var v = zip_heap[k];\n  var j = k << 1;\t// left son of k\n\n  while (j <= zip_heap_len) {\n    // Set j to the smallest of the two sons:\n    if (j < zip_heap_len &&\n      zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j])) { j++; }\n\n    // Exit if v is smaller than both sons\n    if (zip_SMALLER(tree, v, zip_heap[j])) { break; }\n\n    // Exchange v with the smallest son\n    zip_heap[k] = zip_heap[j];\n    k = j;\n\n    // And continue down the tree, setting j to the left son of k\n    j <<= 1;\n  }\n  zip_heap[k] = v;\n}\n\n/* ==========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction zip_gen_bitlen(desc) { // the tree descriptor\n  var tree\t\t= desc.dyn_tree;\n  var extra\t\t= desc.extra_bits;\n  var base\t\t= desc.extra_base;\n  var max_code\t= desc.max_code;\n  var max_length\t= desc.max_length;\n  var stree\t\t= desc.static_tree;\n  var h;\t\t// heap index\n  var n, m;\t\t// iterate over the tree elements\n  var bits;\t\t// bit length\n  var xbits;\t\t// extra bits\n  var f;\t\t// frequency\n  var overflow = 0;\t// number of elements with bit length too large\n\n  for (bits = 0; bits <= zip_MAX_BITS; bits++) { zip_bl_count[bits] = 0; }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\n\n  for (h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\n    n = zip_heap[h];\n    bits = tree[tree[n].dl].dl + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n].dl = bits;\n    // We overwrite tree[n].dl which is no longer needed\n\n    if (n > max_code) { continue; } // not a leaf node\n\n    zip_bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) { xbits = extra[n - base]; }\n    f = tree[n].fc;\n    zip_opt_len += f * (bits + xbits);\n    if (stree != null) { zip_static_len += f * (stree[n].dl + xbits); }\n  }\n  if (overflow == 0) { return; }\n\n  // This happens for example on obj2 and pic of the Calgary corpus\n\n  // Find the first bit length which could increase:\n  do {\n    bits = max_length - 1;\n    while (zip_bl_count[bits] == 0) { bits--; }\n    zip_bl_count[bits]--;\t\t// move one leaf down the tree\n    zip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\n    zip_bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits != 0; bits--) {\n    n = zip_bl_count[bits];\n    while (n != 0) {\n      m = zip_heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m].dl != bits) {\n        zip_opt_len += (bits - tree[m].dl) * tree[m].fc;\n        tree[m].fc = bits;\n      }\n      n--;\n    }\n  }\n}\n\n/* ==========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction zip_gen_codes(tree,\t// the tree to decorate\n  max_code) {\t// largest code with non zero frequency\n  var next_code = new Array(zip_MAX_BITS + 1); // next code value for each bit length\n  var code = 0;\t\t// running code value\n  var bits;\t\t\t// bit index\n  var n;\t\t\t// code index\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= zip_MAX_BITS; bits++) {\n    code = ((code + zip_bl_count[bits - 1]) << 1);\n    next_code[bits] = code;\n  }\n\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //\t    \"inconsistent bit counts\");\n  //    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0; n <= max_code; n++) {\n    var len = tree[n].dl;\n    if (len == 0) { continue; }\n    // Now reverse the bits\n    tree[n].fc = zip_bi_reverse(next_code[len]++, len);\n\n    //      Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n  }\n}\n\n/* ==========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction zip_build_tree(desc) { // the tree descriptor\n  var tree\t= desc.dyn_tree;\n  var stree\t= desc.static_tree;\n  var elems\t= desc.elems;\n  var n, m;\t\t// iterate over heap elements\n  var max_code = -1;\t// largest code with non zero frequency\n  var node = elems;\t// next internal node of the tree\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  zip_heap_len = 0;\n  zip_heap_max = zip_HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n].fc != 0) {\n      zip_heap[++zip_heap_len] = max_code = n;\n      zip_depth[n] = 0;\n    } else { tree[n].dl = 0; }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (zip_heap_len < 2) {\n    var xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[xnew].fc = 1;\n    zip_depth[xnew] = 0;\n    zip_opt_len--;\n    if (stree != null) { zip_static_len -= stree[xnew].dl; }\n    // new is 0 or 1 so it does not have extra bits\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = zip_heap_len >> 1; n >= 1; n--) { zip_pqdownheap(tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  do {\n    n = zip_heap[zip_SMALLEST];\n    zip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\n    zip_pqdownheap(tree, zip_SMALLEST);\n\n    m = zip_heap[zip_SMALLEST];  // m = node of next least frequency\n\n    // keep the nodes sorted by frequency\n    zip_heap[--zip_heap_max] = n;\n    zip_heap[--zip_heap_max] = m;\n\n    // Create a new node father of n and m\n    tree[node].fc = tree[n].fc + tree[m].fc;\n    //\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n    if (zip_depth[n] > zip_depth[m] + 1) { zip_depth[node] = zip_depth[n]; } else { zip_depth[node] = zip_depth[m] + 1; }\n    tree[n].dl = tree[m].dl = node;\n\n    // and insert the new node in the heap\n    zip_heap[zip_SMALLEST] = node++;\n    zip_pqdownheap(tree, zip_SMALLEST);\n\n  } while (zip_heap_len >= 2);\n\n  zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  zip_gen_bitlen(desc);\n\n  // The field len is now set, we can generate the bit codes\n  zip_gen_codes(tree, max_code);\n}\n\n/* ==========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree. Updates opt_len to take into account the repeat\n * counts. (The contribution of the bit length codes will be added later\n * during the construction of bl_tree.)\n */\nfunction zip_scan_tree(tree, // the tree to be scanned\n  max_code) {  // and its largest code of non zero frequency\n  var n;\t\t\t// iterates over all tree elements\n  var prevlen = -1;\t\t// last emitted length\n  var curlen;\t\t\t// length of current code\n  var nextlen = tree[0].dl;\t// length of next code\n  var count = 0;\t\t// repeat count of the current code\n  var max_count = 7;\t\t// max repeat count\n  var min_count = 4;\t\t// min repeat count\n\n  if (nextlen == 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[max_code + 1].dl = 0xffff; // guard\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[n + 1].dl;\n    if (++count < max_count && curlen == nextlen) { continue; } else if (count < min_count) { zip_bl_tree[curlen].fc += count; } else if (curlen != 0) {\n      if (curlen != prevlen) { zip_bl_tree[curlen].fc++; }\n      zip_bl_tree[zip_REP_3_6].fc++;\n    } else if (count <= 10) { zip_bl_tree[zip_REPZ_3_10].fc++; } else { zip_bl_tree[zip_REPZ_11_138].fc++; }\n    count = 0; prevlen = curlen;\n    if (nextlen == 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen == nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n/* ==========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction zip_send_tree(tree, // the tree to be scanned\n  max_code) { // and its largest code of non zero frequency\n  var n;\t\t\t// iterates over all tree elements\n  var prevlen = -1;\t\t// last emitted length\n  var curlen;\t\t\t// length of current code\n  var nextlen = tree[0].dl;\t// length of next code\n  var count = 0;\t\t// repeat count of the current code\n  var max_count = 7;\t\t// max repeat count\n  var min_count = 4;\t\t// min repeat count\n\n  /* tree[max_code+1].dl = -1; */  /* guard already set */\n  if (nextlen == 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[n + 1].dl;\n    if (++count < max_count && curlen == nextlen) {\n      continue;\n    } else if (count < min_count) {\n      do { zip_SEND_CODE(curlen, zip_bl_tree); } while (--count != 0);\n    } else if (curlen != 0) {\n      if (curlen != prevlen) {\n        zip_SEND_CODE(curlen, zip_bl_tree);\n        count--;\n      }\n      // Assert(count >= 3 && count <= 6, \" 3_6?\");\n      zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\n      zip_send_bits(count - 3, 2);\n    } else if (count <= 10) {\n      zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\n      zip_send_bits(count - 3, 3);\n    } else {\n      zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\n      zip_send_bits(count - 11, 7);\n    }\n    count = 0;\n    prevlen = curlen;\n    if (nextlen == 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen == nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n/* ==========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction zip_build_bl_tree() {\n  var max_blindex;  // index of last bit length code of non zero freq\n\n  // Determine the bit length frequencies for literal and distance trees\n  zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\n  zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\n\n  // Build the bit length tree:\n  zip_build_tree(zip_bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = zip_BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  zip_opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //\t    encoder->opt_len, encoder->static_len));\n\n  return max_blindex;\n}\n\n/* ==========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\n  var rank; // index in bl_order\n\n  //    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //\t    \"too many codes\");\n  //    Tracev((stderr, \"\\nbl counts: \"));\n  zip_send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n  zip_send_bits(dcodes - 1,   5);\n  zip_send_bits(blcodes - 4,  4); // not -3 as stated in appnote.txt\n  for (rank = 0; rank < blcodes; rank++) {\n    //      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    zip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\n  }\n\n  // send the literal tree\n  zip_send_tree(zip_dyn_ltree, lcodes - 1);\n\n  // send the distance tree\n  zip_send_tree(zip_dyn_dtree, dcodes - 1);\n}\n\n/* ==========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction zip_flush_block(eof) { // true if this is the last block for a file\n  var opt_lenb, static_lenb; // opt_len and static_len in bytes\n  var max_blindex;\t// index of last bit length code of non zero freq\n  var stored_len;\t// length of input block\n\n  stored_len = zip_strstart - zip_block_start;\n  zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\n\n  // Construct the literal and distance trees\n  zip_build_tree(zip_l_desc);\n  //    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n  //\t    encoder->opt_len, encoder->static_len));\n\n  zip_build_tree(zip_d_desc);\n  //    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n  //\t    encoder->opt_len, encoder->static_len));\n  /* At this point, opt_len and static_len are the total bit lengths of\n   * the compressed block data, excluding the tree representations.\n   */\n\n  /* Build the bit length tree for the above two trees, and get the index\n   * in bl_order of the last bit length code to send.\n   */\n  max_blindex = zip_build_bl_tree();\n\n  // Determine the best encoding. Compute first the block length in bytes\n  opt_lenb\t= (zip_opt_len   + 3 + 7) >> 3;\n  static_lenb = (zip_static_len + 3 + 7) >> 3;\n\n  //    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n  //\t   opt_lenb, encoder->opt_len,\n  //\t   static_lenb, encoder->static_len, stored_len,\n  //\t   encoder->last_lit, encoder->last_dist));\n\n  if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n  if (stored_len + 4 <= opt_lenb // 4: two words for the lengths\n    && zip_block_start >= 0) {\n    var i;\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    zip_send_bits((zip_STORED_BLOCK << 1) + eof, 3);  /* send block type */\n    zip_bi_windup();\t\t /* align on byte boundary */\n    zip_put_short(stored_len);\n    zip_put_short(~stored_len);\n\n    // copy block\n    /*\n      p = &window[block_start];\n      for(i = 0; i < stored_len; i++)\n  put_byte(p[i]);\n  */\n    for (i = 0; i < stored_len; i++) { zip_put_byte(zip_window[zip_block_start + i]); }\n\n  } else if (static_lenb == opt_lenb) {\n    zip_send_bits((zip_STATIC_TREES << 1) + eof, 3);\n    zip_compress_block(zip_static_ltree, zip_static_dtree);\n  } else {\n    zip_send_bits((zip_DYN_TREES << 1) + eof, 3);\n    zip_send_all_trees(zip_l_desc.max_code + 1,\n      zip_d_desc.max_code + 1,\n      max_blindex + 1);\n    zip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\n  }\n\n  zip_init_block();\n\n  if (eof != 0) { zip_bi_windup(); }\n}\n\n/* ==========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction zip_ct_tally(\n  dist, // distance of matched string\n  lc) { // match length-MIN_MATCH or unmatched char (if dist==0)\n  zip_l_buf[zip_last_lit++] = lc;\n  if (dist == 0) {\n    // lc is the unmatched char\n    zip_dyn_ltree[lc].fc++;\n  } else {\n    // Here, lc is the match length - MIN_MATCH\n    dist--;\t\t    // dist = match distance - 1\n    //      Assert((ush)dist < (ush)MAX_DIST &&\n    //\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n    zip_dyn_ltree[zip_length_code[lc] + zip_LITERALS + 1].fc++;\n    zip_dyn_dtree[zip_D_CODE(dist)].fc++;\n\n    zip_d_buf[zip_last_dist++] = dist;\n    zip_flags |= zip_flag_bit;\n  }\n  zip_flag_bit <<= 1;\n\n  // Output the flags if they fill a byte\n  if ((zip_last_lit & 7) == 0) {\n    zip_flag_buf[zip_last_flags++] = zip_flags;\n    zip_flags = 0;\n    zip_flag_bit = 1;\n  }\n  // Try to guess if it is profitable to stop the current block here\n  if (zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\n    // Compute an upper bound for the compressed length\n    var out_length = zip_last_lit * 8;\n    var in_length = zip_strstart - zip_block_start;\n    var dcode;\n\n    for (dcode = 0; dcode < zip_D_CODES; dcode++) {\n      out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\n    }\n    out_length >>= 3;\n    //      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n    //\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\n    //\t     100L - out_length*100L/in_length));\n    if (zip_last_dist < parseInt(zip_last_lit / 2) &&\n      out_length < parseInt(in_length / 2)) { return true; }\n  }\n  return (zip_last_lit == zip_LIT_BUFSIZE - 1 ||\n    zip_last_dist == zip_DIST_BUFSIZE);\n  /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\n/* ==========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction zip_compress_block(\n  ltree,\t// literal tree\n  dtree) {\t// distance tree\n  var dist;\t\t// distance of matched string\n  var lc;\t\t// match length or unmatched char (if dist == 0)\n  var lx = 0;\t\t// running index in l_buf\n  var dx = 0;\t\t// running index in d_buf\n  var fx = 0;\t\t// running index in flag_buf\n  var flag = 0;\t// current flags\n  var code;\t\t// the code to send\n  var extra;\t\t// number of extra bits to send\n\n  if (zip_last_lit != 0) {\n    do {\n      if ((lx & 7) == 0) { flag = zip_flag_buf[fx++]; }\n      lc = zip_l_buf[lx++] & 0xff;\n      if ((flag & 1) == 0) {\n        zip_SEND_CODE(lc, ltree); /* send a literal byte */\n      //\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n      // Here, lc is the match length - MIN_MATCH\n        code = zip_length_code[lc];\n        zip_SEND_CODE(code + zip_LITERALS + 1, ltree); // send the length code\n        extra = zip_extra_lbits[code];\n        if (extra != 0) {\n          lc -= zip_base_length[code];\n          zip_send_bits(lc, extra); // send the extra length bits\n        }\n        dist = zip_d_buf[dx++];\n        // Here, dist is the match distance - 1\n        code = zip_D_CODE(dist);\n        //\tAssert (code < D_CODES, \"bad d_code\");\n\n        zip_SEND_CODE(code, dtree);\t  // send the distance code\n        extra = zip_extra_dbits[code];\n        if (extra != 0) {\n          dist -= zip_base_dist[code];\n          zip_send_bits(dist, extra);   // send the extra distance bits\n        }\n      } // literal or match pair ?\n      flag >>= 1;\n    } while (lx < zip_last_lit);\n  }\n\n  zip_SEND_CODE(zip_END_BLOCK, ltree);\n}\n\n/* ==========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nvar zip_Buf_size = 16; // bit size of bi_buf\nfunction zip_send_bits(\n  value,\t// value to send\n  length) {\t// number of bits\n  /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n   * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n   * unused bits in value.\n   */\n  if (zip_bi_valid > zip_Buf_size - length) {\n    zip_bi_buf |= (value << zip_bi_valid);\n    zip_put_short(zip_bi_buf);\n    zip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\n    zip_bi_valid += length - zip_Buf_size;\n  } else {\n    zip_bi_buf |= value << zip_bi_valid;\n    zip_bi_valid += length;\n  }\n}\n\n/* ==========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction zip_bi_reverse(\n  code,\t// the value to invert\n  len) {\t// its bit length\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >> 1;\n}\n\n/* ==========================================================================\n * Write out any remaining bits in an incomplete byte.\n */\nfunction zip_bi_windup() {\n  if (zip_bi_valid > 8) {\n    zip_put_short(zip_bi_buf);\n  } else if (zip_bi_valid > 0) {\n    zip_put_byte(zip_bi_buf);\n  }\n  zip_bi_buf = 0;\n  zip_bi_valid = 0;\n}\n\nfunction zip_qoutbuf() {\n  if (zip_outcnt != 0) {\n    var q, i;\n    q = zip_new_queue();\n    if (zip_qhead == null) { zip_qhead = zip_qtail = q; } else { zip_qtail = zip_qtail.next = q; }\n    q.len = zip_outcnt - zip_outoff;\n    //      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\n    for (i = 0; i < q.len; i++) { q.ptr[i] = zip_outbuf[zip_outoff + i]; }\n    zip_outcnt = zip_outoff = 0;\n  }\n}\n\nfunction zip_deflate(str, level) {\n  var out, buff;\n  var i, j;\n\n  zip_deflate_data = str;\n  zip_deflate_pos = 0;\n  if (typeof level === 'undefined') { level = zip_DEFAULT_LEVEL; }\n  zip_deflate_start(level);\n\n  buff = new Array(1024);\n  out = '';\n  while ((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\n    for (j = 0; j < i; j++) { out += String.fromCharCode(buff[j]); }\n  }\n  zip_deflate_data = null; // G.C.\n  return out;\n}\n\nfunction encode64(data) {\n  var r = '';\n  for (var i = 0; i < data.length; i += 3) {\n    if (i + 2 == data.length) {\n      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\n    } else if (i + 1 == data.length) {\n      r += append3bytes(data.charCodeAt(i), 0, 0);\n    } else {\n      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), data.charCodeAt(i + 2));\n    }\n  }\n  return r;\n}\n\nfunction append3bytes(b1, b2, b3) {\n  var c1 = b1 >> 2;\n  var c2 = ((b1 & 0x3) << 4) | (b2 >> 4);\n  var c3 = ((b2 & 0xF) << 2) | (b3 >> 6);\n  var c4 = b3 & 0x3F;\n  var r = '';\n  r += encode6bit(c1 & 0x3F);\n  r += encode6bit(c2 & 0x3F);\n  r += encode6bit(c3 & 0x3F);\n  r += encode6bit(c4 & 0x3F);\n  return r;\n}\n\nfunction encode6bit(b) {\n  if (b < 10) {\n    return String.fromCharCode(48 + b);\n  }\n  b -= 10;\n  if (b < 26) {\n    return String.fromCharCode(65 + b);\n  }\n  b -= 26;\n  if (b < 26) {\n    return String.fromCharCode(97 + b);\n  }\n  b -= 26;\n  if (b == 0) {\n    return '-';\n  }\n  if (b == 1) {\n    return '_';\n  }\n  return '?';\n}\n","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar rendererRule = exports.rendererRule = function rendererRule(tokens, idx, options) {\n  return options.replace(tokens[idx].content);\n};\n\nvar coreRuler = exports.coreRuler = function coreRuler(state, options) {\n  for (var i = 0; i < state.tokens.length; i++) {\n    if (state.tokens[i].type !== 'inline') {\n      continue;\n    }\n    var tokens = state.tokens[i].children;\n    for (var j = tokens.length - 1; j >= 0; j--) {\n      var token = tokens[j];\n      if (token.type === 'text' && options.regex.test(token.content)) {\n        var newTokens = token.content.split(options.regex).map(function (item, index) {\n          return { type: index % 2 === 0 ? 'text' : options.name, content: item };\n        }).filter(function (item) {\n          return item.content.length > 0;\n        }).map(function (item) {\n          var newToken = new state.Token(item.type, '', 0);\n          newToken.content = item.content;\n          return newToken;\n        });\n        state.tokens[i].children = tokens = [].concat(_toConsumableArray(tokens.slice(0, j)), _toConsumableArray(newTokens), _toConsumableArray(tokens.slice(j + 1)));\n      }\n    }\n  }\n};\n\nvar regexPlugin = function regexPlugin(md, options) {\n  md.renderer.rules[options.name] = function (tokens, idx) {\n    return rendererRule(tokens, idx, options);\n  };\n\n  md.core.ruler.push(options.name, function (state) {\n    coreRuler(state, options);\n  });\n};\n\nexports.default = regexPlugin;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0d1a0c903c89c60b9ef4","export const rendererRule = (tokens, idx, options) => {\n  return options.replace(tokens[idx].content)\n}\n\nexport const coreRuler = (state, options) => {\n  for (let i = 0; i < state.tokens.length; i++) {\n    if (state.tokens[i].type !== 'inline') {\n      continue\n    }\n    let tokens = state.tokens[i].children\n    for (let j = tokens.length - 1; j >= 0; j--) {\n      let token = tokens[j]\n      if (token.type === 'text' && options.regex.test(token.content)) {\n        const newTokens = token.content.split(options.regex)\n          .map((item, index) => ({ type: (index % 2 === 0 ? 'text' : options.name), content: item }))\n          .filter((item) => item.content.length > 0)\n          .map((item) => {\n            const newToken = new state.Token(item.type, '', 0)\n            newToken.content = item.content\n            return newToken\n          })\n        state.tokens[i].children = tokens = [...tokens.slice(0, j), ...newTokens, ...tokens.slice(j + 1)]\n      }\n    }\n  }\n}\n\nconst regexPlugin = (md, options) => {\n  md.renderer.rules[options.name] = (tokens, idx) => {\n    return rendererRule(tokens, idx, options)\n  }\n\n  md.core.ruler.push(options.name, (state) => {\n    coreRuler(state, options)\n  })\n}\n\nexport default regexPlugin\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import superPropBase from \"@babel/runtime/helpers/esm/superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import { useRef, useState, useEffect, useMemo, useCallback } from 'react';\n\n// This of course could've been more streamlined with internal state instead of\n// refs, but then host hooks / components could not opt out of renders.\n// This could've been exported to its own module, but the current build doesn't\n// seem to work with module imports and I had no more time to spend on this...\nfunction useResolvedElement(subscriber, refOrElement) {\n  var _ref;\n\n  // The default ref has to be non-conditionally declared here whether or not\n  // it'll be used as that's how hooks work.\n  // @see https://reactjs.org/docs/hooks-rules.html#explanation\n  var ref = null; // Default ref\n\n  var refElement = useRef(null);\n  var callbackRefElement = useRef(null);\n  var refCallback = useCallback(function (element) {\n    callbackRefElement.current = element;\n    callSubscriber();\n  }, []);\n  var lastReportedElementRef = useRef(null);\n  var cleanupRef = useRef();\n\n  var callSubscriber = function callSubscriber() {\n    var element = null;\n\n    if (callbackRefElement.current) {\n      element = callbackRefElement.current;\n    } else if (refElement.current) {\n      element = refElement.current;\n    } else if (refOrElement instanceof HTMLElement) {\n      element = refOrElement;\n    }\n\n    if (lastReportedElementRef.current === element) {\n      return;\n    }\n\n    if (cleanupRef.current) {\n      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.\n\n      cleanupRef.current = null;\n    }\n\n    lastReportedElementRef.current = element; // Only calling the subscriber, if there's an actual element to report.\n\n    if (element) {\n      cleanupRef.current = subscriber(element);\n    }\n  };\n\n  if (refOrElement && !(refOrElement instanceof HTMLElement)) {\n    // Overriding the default ref with the given one\n    ref = refOrElement;\n  } // On each render, we check whether a ref changed, or if we got a new raw\n  // element.\n\n\n  useEffect(function () {\n    // Note that this does not mean that \"element\" will necessarily be whatever\n    // the ref currently holds. It'll simply \"update\" `element` each render to\n    // the current ref value, but there's no guarantee that the ref value will\n    // not change later without a render.\n    // This may or may not be a problem depending on the specific use case.\n    if (ref) {\n      refElement.current = ref.current;\n    }\n\n    callSubscriber();\n  }, [ref, (_ref = ref) == null ? void 0 : _ref.current, refOrElement]);\n  return refCallback;\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(function (element) {\n    // Initialising the RO instance\n    if (!resizeObserverRef.current) {\n      // Saving a single instance, used by the hook from this point on.\n      resizeObserverRef.current = new ResizeObserver(function (entries) {\n        if (!Array.isArray(entries)) {\n          return;\n        } // Since we only observe the one element, we don't need to loop over the\n        // array\n\n\n        if (!entries.length) {\n          return;\n        }\n\n        var entry = entries[0]; // `Math.round` is in line with how CSS resolves sub-pixel values\n\n        var newWidth = Math.round(entry.contentRect.width);\n        var newHeight = Math.round(entry.contentRect.height);\n\n        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n          var newSize = {\n            width: newWidth,\n            height: newHeight\n          };\n\n          if (onResizeRef.current) {\n            onResizeRef.current(newSize);\n          } else {\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (!didUnmount.current) {\n              setSize(newSize);\n            }\n          }\n        }\n      });\n    }\n\n    resizeObserverRef.current.observe(element);\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.unobserve(element);\n      }\n    };\n  }, opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size ? size.width : null, size ? size.height : null]);\n}\n\nexport default useResizeObserver;\n"],"sourceRoot":""}